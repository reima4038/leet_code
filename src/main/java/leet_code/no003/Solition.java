/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package leet_code.no003;

import java.util.Objects;

/*
    Example 1:
    Input: "abcabcbb"
    Output: 3 
    Explanation: The answer is "abc", with the length of 3. 

    Example 2:
    Input: "bbbbb"
    Output: 1
    Explanation: The answer is "b", with the length of 1.

    Example 3:
    Input: "pwwkew"
    Output: 3
    Explanation: The answer is "wke", with the length of 3. 
    Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

    * 文字長がnullの場合0を返却して処理を終了する。
    * 文字長が0の場合0を返却して処理を終了する。
    * 文字長が1の場合1を返却して処理を終了する。
    * 文字長が2以上の場合は先頭の文字を比較元とし、以降の文字列を末尾まで比較する。
        * 一致せず末尾の文字列まで探索した場合は比較元をすすめて再度比較する。
        * 一致する文字があればその一つ前の文字までの長さを仮の答えとする。
            * 仮の答えが既に存在する場合、より大きな値であれば仮の答えを更新する。
        * 一致した文字が末尾でなければ一致した文字からまた比較する。
    * すべての文字比較で一度以上一致した場合、仮の答えを返却して処理を終了する。
    * すべての文字比較で一度も一致しなければ与えられた文字列長を返却して処理を終了する。
*/

class Solution {
    /**
     * 文字列から繰り返しのないsubstringの長さを取得する
     * @param s
     * @return length of longest substring
     */
    public int lengthOfLongestSubstring(String s) {
        if (Objects.isNull(s)){
            return 0;
        }
        if (s.length() == 0) {
            return 0;
        }
        if (s.length() == 1){
            return 1;
        }

        int answer = 0;
        boolean isMatching = false;
        for(int i = 0; i < s.length(); i++){
            final char source = s.charAt(i);
            for(int j = i + 1; j < s.length(); j++) {
                final char target = s.charAt(j);
                if(source == target) {
                    if(answer < j - i) {
                        answer = j - i;
                        isMatching = true;
                    }
                    break;
                } else if(hasNotRepetationChars(s.substring(j))){
                    //cdd
                    if(answer < j - i) {
                        answer = j - i;
                        isMatching = true;
                    }
                    break;
                } else if(j == s.length() - 1 && hasNotRepetationChars(s.substring(i))){
                    if(answer < j - i + 1){
                        answer = j - i + 1;
                        isMatching = true;
                    }
                    break;
                }
            }
        }
        
        return isMatching ? answer : s.length();
    }

    /**
     * 文字列の繰り返しを検査する
     */
    private boolean hasNotRepetationChars(String s) {
        for(int i = 0; i < s.length(); i++) {
            if(s.substring(i + 1).contains(String.valueOf(s.charAt(i)))){
                return false;
            };
        }
        return true;
    }

}